## Structural 构建型模式 ##

这些设计模式关注类和对象的组合

* **adapter 适配器模式 :** 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
* **decorator 装饰器模式 :** 保持接口，增强性能：修饰类继承被修饰对象的抽象父类，依赖被修饰对象的实例（被修饰对象依赖注入），以实现接口扩展
* **bridge 桥接模式 :** 两个维度独立变化，依赖方式实现抽象与实现分离：需要一个作为桥接的接口/抽象类，多个角度的实现类依赖注入到抽象类，使它们在抽象层建立一个关联关系
* **facade 外观模式 :** 在客户端和复杂系统之间再加一层，这一次将调用顺序、依赖关系等处理好。即封装底层实现，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的高层接口
* **proxy 代理模式 :** 为其他对象提供一种代理以控制对这个对象的访问：增加中间层（代理层），代理类与底层实现类实现共同接口，并创建底层实现类对象（底层实现类对象依赖注入代理类），以便向外界提供功能接口
* **filter 过滤器模式 :** 使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来
* **composite 组合模式 :** 将对象组合成树结构以表示部分整体层次结构。 Composite允许客户端统一处理单个对象和对象组合。
* **flyweight 享元模式 :** 享元工厂类控制；Map实现缓冲池重用现有的同类对象，如果未找到匹配的对象，则创建新对象
